{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwap where

import           Plutus.V2.Ledger.Api      (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken,
                                             adaSymbol, singleton, TxInInfo (TxInInfo, txInInfoResolved), TxInfo (txInfoInputs),
                                             TxOut (txOutValue), toData)
import           Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo, findOwnInput, valueSpent)
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer, BuiltinString, toBuiltin)
import           PlutusTx.Builtins.Class  (stringToBuiltinString)
import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse, Maybe (Nothing, Just), ($), (&&), length, Ord ((>),(<)))
import           Utilities                 (wrapValidator)
import Data.Aeson (Value(Bool))
import Plutus.V1.Ledger.Value
-- import Prelude (Show(..), String, not, (||))

---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> () -> ScriptContext -> Bool
mkValidator ds _ ctx = traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary &&
                      --  traceIfFalse "Cheap fool! You can only get one token for that price!" False &&
                       traceIfFalse "length is not 2" leng2 &&
                      --  traceIfFalse "length is 2" (not leng2)
                       traceIfFalse "OneCoin - not 1" oneCoinInput &&
                       traceIfFalse "OneCoin - not 2" oneCoinInput2
                      --  traceIfFalse "OneCoin 1 & 2" False
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        -- txInput :: TxInInfo
        -- [txInput] = txInfoInputs txInfo

        -- txInValue :: Plutus.V1.Ledger.Value.Value
        -- txInValue =  txOutValue $ txInInfoResolved txInput

        txInValue :: Plutus.V1.Ledger.Value.Value
        txInValue = valueSpent txInfo

        leng2 :: Bool
        leng2 = 2 == length (flattenValue txInValue)

        outputToBeneficiary :: Bool
        outputToBeneficiary = 
          valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)
          -- The price of the NFT (stated in the datum) must be paid to the beneficiary in the same txn to unlock the script

        oneCoinInput :: Bool
        oneCoinInput = case flattenValue txInValue of
                          -- [(_,_,amt)] -> amt == 100
                          [(_,_,amt),(_,_,amt2)] -> amt == 1
                          _ -> True
        
        oneCoinInput2 :: Bool
        oneCoinInput2 = case flattenValue txInValue of
                          [(_,_,amt),(_,_,amt2)] -> amt2 > 99 && amt < 100
                          _ -> True
        --(currencySymbol "55925dd7d74d6cfb4b26cde5db2312376811b83f691f82738ff367ed", tokenName "Super-Cool-Token", amt)


{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])
