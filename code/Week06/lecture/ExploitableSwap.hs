{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwap where

import           Plutus.V2.Ledger.Api      (ScriptContext (scriptContextTxInfo), PubKeyHash, Validator, mkValidatorScript, adaToken,
                                             adaSymbol, singleton, TxInInfo (TxInInfo, txInInfoResolved), TxInfo (txInfoInputs),
                                             TxOut (txOutValue), toData)
import           Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo, findOwnInput, valueSpent)
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer, BuiltinString, toBuiltin)
import           PlutusTx.Builtins.Class  (stringToBuiltinString)
import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse, ($), (&&), length, Ord ((>),(<)), filter)
import           Utilities                 (wrapValidator)
import Data.Aeson (Value(Bool))
import Plutus.V1.Ledger.Value
---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> () -> ScriptContext -> Bool
mkValidator ds _ ctx = traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary &&
                       traceIfFalse "Cheap fool! You can only get one token for that price!" oneTokenInput &&
                       traceIfFalse "Just double checking incase u did something funny." oneTokenInput2
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        txInValue :: Plutus.V1.Ledger.Value.Value
        txInValue = valueSpent txInfo

        outputToBeneficiary :: Bool
        outputToBeneficiary = 
          valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)
          -- The price of the Token (stated in the datum) must be paid to the beneficiary in the same txn to unlock the script

        -- Here we filter the Txn inputs and find the exact asset class we are looking for and make sure the amount is exactly one
        filteredTxInInfos :: [(CurrencySymbol, TokenName, Integer)]
        filteredTxInInfos = filter isCorrectAsset (flattenValue txInValue)
          where isCorrectAsset = \(curSym, tokName, amt) -> 
                                          -- curSym == CurrencySymbol "55925dd7d74d6cfb4b26cde5db2312376811b83f691f82738ff367ed" &&
                                          tokName == TokenName "Super-Cool-Token" &&
                                          amt == 1  -- The Value amount of this Token must be exactly one (we can buy only one token per txn)

        -- Check only by amount
        oneTokenInput :: Bool
        oneTokenInput = length filteredTxInInfos == 1
        
        oneTokenInput2 :: Bool
        oneTokenInput2 = case flattenValue txInValue of
                          [(_,_,amt),(_,_,amt2)] -> amt == 1 -- && (amt2 > 99 && amt2 < 101)
                          _ -> False
          -- There are exactly two inputs in this transaction (the token and the UTxO paid to the beneficiary)
              -- The token provided as an input to the txn must be exactly one and the price must be (~ 100 ?) to avoid double spending
              -- We are checking for a specific AssetClass, so the amount of tokens will be added up instead being their own individual inputs to the txn.

{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])
