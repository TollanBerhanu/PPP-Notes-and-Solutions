{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Plutus.Model         (Run,
                                       TypedValidator (TypedValidator),
                                       adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue, newUser, Ada (Lovelace), ada, UserSpend, Tx, userSpend,
                                       payToKey, payToScript, DatumMode (HashDatum), spendScript, spend, submitTx, valueAt, logError, boxAt, utxoAt)
import           PlutusTx.Prelude     (($))
import           Prelude              (IO, (.), (<>), Monoid (mconcat), Eq ((==)), (&&), Show (show), (++))
import qualified ExploitableSwap      as OnChain

import           Test.Tasty           (defaultMain, testGroup)

import           Control.Monad        (mapM, unless)
import Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue))
import           PlutusTx.Builtins    (Integer)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ 
        good "Normal spending" normalSpending,
        bad  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

-- Import the validator script and assign it so swapScript
swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

-- create the Txn for locking the "Super-Cool-Token" at the script address
lockingTx ::  PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx ben pri usp val =
  mconcat       -- 'mconcat' takes a list of Monoid values (individual txns) and concatenates them 
    [ userSpend usp  -- specify everything the user spends (the Tokens) to create the txn 
    , payToScript swapScript (HashDatum (OnChain.DatumSwap ben pri)) val -- create the txn to pay to the script, with the hashed datum and the Token (Value) we send
    ]

-- Create the txn for consuming the token at the script address
consumingTx :: PubKeyHash -> Integer -> UserSpend -> PubKeyHash -> TxOutRef -> Value -> Tx
consumingTx ben pri pay usr ref val =
  mconcat
    [ 
      spendScript swapScript ref () (OnChain.DatumSwap ben pri) -- specify what is to be consumed (the Token at the script) with the Datum (beneficiary, price)
    , userSpend pay -- specify everything the user spends as input (UTxO / the price of one Token in Ada)
    , payToKey ben (adaValue pri)  -- send the price amount in ADA to the beneficiary
    , payToKey usr val   -- send the Token Value (whatever is at the script) to the user (back to our address)
    ]

-- Create the txn for consuming two tokens at the script address while only paying once
doubleConsumingTx :: PubKeyHash -> Integer -> UserSpend -> PubKeyHash -> TxOutRef -> TxOutRef -> Value -> Value -> Tx
doubleConsumingTx ben pri pay usr ref ref2 val val2 =
  mconcat
    [ 
      spendScript swapScript ref () (OnChain.DatumSwap ben pri) -- specify the first Token we consume (UTxO1 + datum)
    , spendScript swapScript ref2 () (OnChain.DatumSwap ben pri) -- specify the second Token we consume (UTxO2 + datum)
    , userSpend pay -- specify the input we are willing to provide
    , payToKey ben (adaValue pri)  -- send the price amount in ADA to the beneficiary's address
    , payToKey usr val  -- send the first Token at the script address to our own wallet
    , payToKey usr val2  -- send the second Token at the script address to our own wallet
    ]
  
---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run ()
normalSpending = do
  -- Setting up users
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)
  u2 <- newUser (ada 1000)

  -- USER 1 locks 1 "Super-Cool-Token" in SwapScript
  let val = fakeValue scToken 1             -- Define value to be transfered
  sp <- spend u1 val                        -- Get User 1's UTXOs that we provide as input (must match the price because all will be consumed)
  submitTx u1 $ lockingTx u1 100 sp val     -- User 1 submits the txn that locks the token at the swap script 

  -- USER 2 buys 1 "Super-Cool-Token" from the SwapScript
  utxos <- utxoAt swapScript                -- Query the mock blockchain to get all UTxOs/Tokens at SwapScript ... utxosAt :: script -> Run [(TxOutRef, TxOut)]
  let [(ref, out)] = utxos
  pay <- spend u2 (adaValue 100)            -- We know there is only one UTXO / Token (the one we sent before)
  submitTx u2 $ consumingTx u1 100 pay u2 ref (txOutValue out)     -- User 2 submits the txn to buy 1 "Super-Cool-Token" for 100 ADA
  
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless (v1 == adaValue 1100 && v2 == (adaValue 900 <> fakeValue scToken 1)) $  -- Check if final balances match expected balances
        -- User 1 gets 100 ADA and User 2 loses 100 ADA and gets the Token
    logError $ "Final balances are incorrect: " ++ show v1 ++ " **** " ++ show v2   


doubleSpending :: Run ()
doubleSpending = do
  -- Setting up users
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1 <> fakeValue scToken 1) -- User 1 has 2  "Super-Cool-Token"s (we can also do: scToken 2) 
  u2 <- newUser (ada 1000)

   -- USER 1 locks 1 "Super-Cool-Token" in SwapScript
  let val = fakeValue scToken 1 
  sp <- spend u1 val              
  submitTx u1 $ lockingTx u1 100 sp val

   -- USER 1 locks 1 "Super-Cool-Token" in SwapScript again ... this results in two distinct UTxOs at the SwapScript address (they have the same AssetClass value tho)
  sp2 <- spend u1 val                
  submitTx u1 $ lockingTx u1 100 sp2 val

  -- USER 2 buys 2 "Super-Cool-Token"s from the SwapScript while paying for only one
  utxos <- utxoAt swapScript             
  let [(ref, out), (ref2, out2)] = utxos    -- We know there are exactly two UTxOs sitting at SwapScript 
  pay <- spend u2 (adaValue 100)            -- We specify the inputs we want to include in the txn (price of one Token)
  submitTx u2 $ doubleConsumingTx u1 100 pay u2 ref ref2 (txOutValue out) (txOutValue out2)   -- We submit the txn we defined: doubleConsumingTx

  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                                         -- Get final balances of both users
  unless (v1 == adaValue 1000 && v2 == adaValue 1000) $                     -- Check if final balances match expected balances
    logError $ "Final balances are incorrect: " ++ show v1 ++ " **** " ++ show v2   