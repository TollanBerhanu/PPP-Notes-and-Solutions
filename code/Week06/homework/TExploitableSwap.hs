{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE NoImplicitPrelude  #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings  #-}

module Main where

import           Plutus.Model         (Run,
                                       TypedValidator (TypedValidator),
                                       adaValue, defaultBabbage, mustFail, testNoErrors,
                                       toV2, FakeCoin (FakeCoin), fakeValue, newUser, Ada (Lovelace), ada, UserSpend, Tx, userSpend,
                                       payToKey, payToScript, DatumMode (HashDatum), spendScript, spend, submitTx, valueAt, logError, boxAt, utxoAt)
import           PlutusTx.Prelude     (($))
import           Prelude              (IO, (.), (<>), undefined, Monoid (mconcat), Eq ((==)), (&&), Show (show), (++))
import qualified ExploitableSwap      as OnChain
-- import qualified UnExploitableSwap    as OnChainHomework

import           Test.Tasty           (defaultMain, testGroup)

import           Control.Monad        (replicateM, mapM, unless)
import Plutus.V2.Ledger.Api (PubKeyHash, Value, TxOutRef, TxOut (txOutValue))
import           PlutusTx.Builtins    (Integer)

---------------------------------------------------------------------------------------------------
------------------------------------------ TESTING ------------------------------------------------

main :: IO ()
main = do
  defaultMain $ do
    testGroup
      "Catch double spend with testing"
      [ 
        -- good "Normal spending" normalSpending
       good  "Double spending" doubleSpending
      ]
 where
    bad msg = good msg . mustFail
    good = testNoErrors (adaValue 10_000_000 <> fakeValue scToken 100) defaultBabbage

---------------------------------------------------------------------------------------------------
----------------------------- HELPER FUNCTIONS/INSTANCES/TYPES ------------------------------------

scToken :: FakeCoin
scToken = FakeCoin "Super-Cool-Token"
 
type HomeworkScript = TypedValidator OnChain.DatumSwap ()

swapScript :: HomeworkScript
swapScript = TypedValidator $ toV2 OnChain.validator

lockingTx ::  PubKeyHash -> Integer -> UserSpend -> Value -> Tx
lockingTx ben pri usp val =
  mconcat       -- 'mconcat' takes a list of Monoid values (individual txns) and concatenates them 
    [ userSpend usp       -- userSpend :: UserSpend -> Tx 
        -- specify everything the user spends (the UTxOs consumed) to create the txn (we extract the Tx from UserSpend)
    , payToScript swapScript (HashDatum (OnChain.DatumSwap ben pri)) val    -- payToScript :: script -> DatumMode (DatumType script) -> Value -> Tx
                      --  newtype CustomDatum = MkCustomDatum { deadline :: POSIXTime } ... defined in lecture/NegativeRTimed.hs
        -- create the txn to pay to the script, with the datum (it's hashed in this case) and the Value we send
    ]

consumingTx :: PubKeyHash -> Integer -> UserSpend -> PubKeyHash -> TxOutRef -> Value -> Tx
consumingTx ben pri pay usr ref val =
  mconcat
    [ 
      spendScript swapScript ref () (OnChain.DatumSwap ben pri) -- spendScript :: script -> TxOutRef -> RedeemerType script -> DatumType script -> Tx
        -- specify what is to be spent (the UTxO at the script) with the redeemer and datum
    , userSpend pay 
    , payToKey ben (adaValue pri)  -- payToKey :: pubKeyHash -> Value -> Tx
    , payToKey usr val  -- payToKey :: pubKeyHash -> Value -> Tx
        -- specify where to send funds we unlock (our own pkh / wallet)
    ]


doubleConsumingTx :: PubKeyHash -> Integer -> UserSpend -> PubKeyHash -> TxOutRef -> Value -> Tx
doubleConsumingTx ben pri pay usr ref val =
  mconcat
    [ 
      spendScript swapScript ref () (OnChain.DatumSwap ben pri) -- spendScript :: script -> TxOutRef -> RedeemerType script -> DatumType script -> Tx
        -- specify what is to be spent (the UTxO at the script) with the redeemer and datum
    , userSpend pay 
    , payToKey ben (adaValue pri)  -- payToKey :: pubKeyHash -> Value -> Tx
    , payToKey usr val  -- payToKey :: pubKeyHash -> Value -> Tx
    , payToKey usr val  -- payToKey :: pubKeyHash -> Value -> Tx
        -- specify where to send funds we unlock (our own pkh / wallet)
    ]
  
---------------------------------------------------------------------------------------------------
-------------------------------------- TESTING SPENDING -------------------------------------------

normalSpending :: Run ()
normalSpending = do
  -- Setting up users
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1)
  u2 <- newUser (ada 1000)

   -- USER 1 LOCKS 100 Lovelaces ("val") IN VALIDATOR
  let val = fakeValue scToken 1                   -- Define value to be transfered
  sp <- spend u1 val                        -- Get user's UTXO that we should spend ... spend :: PubKeyHash -> Value -> Run UserSpend
  submitTx u1 $ lockingTx u1 100 sp val

  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script ... utxosAt :: script -> Run [(TxOutRef, TxOut)]
  let [(ref, out)] = utxos
  pay <- spend u2 (adaValue 100)                     -- We know there is only one UTXO (the one we created before)
  submitTx u2 $ consumingTx u1 100 pay u2 ref (txOutValue out)     -- User 2 submits "consumingTx" transaction ... submitTx :: PubKeyHash -> Tx -> Run
  
  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless (v1 == adaValue 1100 && v2 == (adaValue 900 <> fakeValue scToken 10)) $  -- Check if final balances match expected balances ... unless :: Bool -> f () -> f ()
    logError $ "Final balances are incorrect" ++ show v1 ++ show v2   


doubleSpending :: Run ()
doubleSpending = do
  -- Setting up users
  u1 <- newUser (adaValue 1000 <> fakeValue scToken 1 <> fakeValue scToken 1)
  u2 <- newUser (ada 1000)

   -- USER 1 LOCKS 100 Lovelaces ("val") IN VALIDATOR
  let val = fakeValue scToken 1               -- Define value to be transfered
  sp <- spend u1 val                        -- Get user's UTXO that we should spend ... spend :: PubKeyHash -> Value -> Run UserSpend
  submitTx u1 $ lockingTx u1 100 sp val

   -- USER 1 LOCKS 100 Lovelaces ("val") IN VALIDATOR
  let val2 = fakeValue scToken 1                -- Define value to be transfered
  sp2 <- spend u1 val2                        -- Get user's UTXO that we should spend ... spend :: PubKeyHash -> Value -> Run UserSpend
  submitTx u1 $ lockingTx u1 200 sp2 val2

  -- USER 2 TAKES "val" FROM VALIDATOR
  utxos <- utxoAt swapScript                 -- Query blockchain to get all UTxOs at script ... utxosAt :: script -> Run [(TxOutRef, TxOut)]
  let [(ref, out),(ref2, out2)] = utxos
  pay <- spend u2 (adaValue 100)                     -- We know there is only one UTXO (the one we created before)
  submitTx u2 $ consumingTx u1 100 pay u2 ref (txOutValue out)     -- User 2 submits "consumingTx" transaction ... submitTx :: PubKeyHash -> Tx -> Run

  -- CHECK THAT FINAL BALANCES MATCH EXPECTED BALANCES
  [v1, v2] <- mapM valueAt [u1, u2]                     -- Get final balances of both users
  unless (v1 == adaValue 1100 && v2 == (adaValue 900 <> fakeValue scToken 2)) $  -- Check if final balances match expected balances ... unless :: Bool -> f () -> f ()
    logError $ "Final balances are incorrect" ++ show v1 ++ show v2   